package io.github.andreypfau.tl.generator

import io.github.andreypfau.tl.parser.TLGrammar
import io.github.andreypfau.tl.parser.ast.*
import java.io.File
import kotlin.math.exp

fun main(args: Array<String>) {
    val rawProgram = File("/Users/andreypfau/IdeaProjects/tl-kotlin/tl-generator/resources/ton_api.tl").readText()
    val tlProgram = TLGrammar.parseOrThrow(rawProgram)
    val tlGenerator =
        TLGenerator(tlProgram, "tl", File("/Users/andreypfau/IdeaProjects/tl-kotlin/tl-generator/resources/"))
    tlGenerator.generate()
}

internal class TLGenerator(
    val tlProgram: TLProgram,
    val rootPackage: String,
    val file: File
) {
    init {
        file.parentFile.mkdirs()
    }

    private val typeMap = LinkedHashMap<String, MutableList<CombinatorDeclaration>>()

    fun generate() {
        populateTypeMap()

        typeMap.forEach { boxedTypeName, combinators ->
            val typeFile = File(file, boxedTypeName.split(".").let {
                buildString {
                    it.forEachIndexed { index, part ->
                        if (index != 0) append("/")
                        if (index == it.lastIndex) {
                            val name =
                                boxedTypeName.split(".").joinToString("") { it.replaceFirstChar { it.uppercaseChar() } }
                            append(name)
                        } else {
                            append(part.lowercase())
                        }
                    }
                }
            } + ".kt")
            val filePackage = rootPackage + boxedTypeName.lowercase().split(".").dropLast(1).joinToString(".").let {
                if (it.isEmpty()) "" else ".$it"
            }
            TLFileGenerator(this, typeFile, filePackage, combinators).generate()
        }
    }

    fun getCombinatorClassName(combinator: CombinatorDeclaration): String {
        val superType = typeMap[combinator.resultType.id.name] ?: listOf()
        if (superType.size > 1) {
            val names = superType?.map { it.id.name.split(".").dropLast(1).joinToString(".") } ?: listOf()
            return combinator.id.name.removePrefix(findCommonPrefix(names)).split(".").joinToString("") {
                it.replaceFirstChar { it.uppercaseChar() }
            }
        } else {
            return combinator.resultType.id.name.split(".").joinToString("") {
                it.replaceFirstChar { it.uppercaseChar() }
            }
        }
    }

    fun getCombinatorPackage(combinator: CombinatorDeclaration): String {
        return rootPackage + combinator.resultType.id.name.lowercase().split(".").dropLast(1).joinToString(".").let {
            if (it.isEmpty()) "" else ".$it"
        }
    }

    fun getTypeClassName(string: String): String {
        return string.split(".").joinToString("") { it.replaceFirstChar { it.uppercaseChar() } }
    }

    fun getTypeClassName(resultType: ResultType): String {
        return getTypeClassName(resultType.id.name)
    }

    private fun populateTypeMap() {
        tlProgram.constructors.declarations.forEach { decl ->
            when (decl) {
                is BuiltinCombinatorDeclaration -> {}
                is CombinatorDeclaration -> {
                    val id = decl.id.name
                    when (id) {
                        "bytes", "true", "boolTrue", "boolFalse", "vector", "int128", "int256" -> return@forEach
                    }
                    val typeCombinators = typeMap.getOrPut(decl.resultType.id.name) { ArrayList() }
                    typeCombinators.add(decl)
                }

                is EmptyDeclaration -> TODO()
                is FinalDeclaration -> TODO()
                is NewDeclaration -> TODO()
                is PartialCombinatorApplicationDeclaration -> TODO()
                is PartialTypeApplicationDeclaration -> TODO()
            }
        }
    }

    private fun StringBuilder.appendHeaderDisclaimer() {
        append(
            """
            //////////////////////////////////////////////
            // This file is generated by TLGenerator.kt //
            // Do not edit manually!                    //
            //////////////////////////////////////////////
            
        """.trimIndent()
        )
    }
}

private class TLFileGenerator(
    val generator: TLGenerator,
    val file: File,
    val rootPackage: String,
    val combinators: List<CombinatorDeclaration>
) {
    private var indent = 0
    private val builder = StringBuilder()

    private var packageName: String = ""
    private var classes: List<GeneratedClass> = ArrayList()
    private var interfaces: List<GeneratedInterface> = ArrayList()

    class GeneratedClass(
        val serialName: String,
        val name: String,
        val superName: String,
        val fields: List<GeneratedField>
    ) {
        override fun toString(): String {
            val superName = if (superName == "Any") {
                ""
            } else {
                " : $superName"
            }
            if (fields.isEmpty()) {
                return "@Serializable\n@SerialName(\"${serialName}\")\npublic data object $name$superName"
            }

            val fields = fields.joinToString("\n") {
                it.toString().lines().joinToString("\n") {
                    "    $it"
                }
            }

            return "@Serializable\n@SerialName(\"${serialName}\")\npublic class $name(\n${fields}\n)$superName"
        }
    }

    class GeneratedField(
        val name: String,
        val type: String,
    ) {
        override fun toString(): String {
            val fieldName = name.split("_").joinToString("") {
                it.replaceFirstChar { it.uppercaseChar() }
            }.replaceFirstChar { it.lowercaseChar() }
            val serialName = if (fieldName != name) {
                "@SerialName(\"$name\")\n"
            } else {
                ""
            }
            return "${serialName}public val $fieldName: $type,"
        }
    }

    class GeneratedInterface(
        val name: String,
        val subclasses: List<GeneratedClass>
    ) {
        override fun toString(): String {
            val classes = subclasses.joinToString("\n\n") {
                it.toString().lines().joinToString("\n") {
                    "    $it"
                }
            }
            println("classes: \n$classes")
            return "public sealed interface $name {\n$classes\n}"
        }
    }

    fun generate() {
        file.parentFile.mkdirs()
        generateFile()
        file.writeText(builder.toString())
    }

    private fun generateFile() {
        packageName = generator.getCombinatorPackage(combinators.first())

        if (combinators.size > 1) {
            val interfaceName = file.nameWithoutExtension
            val subclasses = combinators.map { combinator ->
                val className = generator.getCombinatorClassName(combinator)
                val fields = generateFields(combinator)
                GeneratedClass(combinator.id.name, className, interfaceName, fields)
            }
            interfaces = listOf(GeneratedInterface(interfaceName, subclasses))
        } else {
            val combinator = combinators.first()
            val className = generator.getCombinatorClassName(combinator)
            val fields = generateFields(combinator)
            classes = listOf(GeneratedClass(combinator.id.name, className, "Any", fields))
        }

        builder.appendLine("package $packageName")
        builder.appendLine()
        interfaces.forEach {
            builder.appendLine(it.toString())
        }
        classes.forEach {
            builder.appendLine(it.toString())
        }
    }

    private fun generateFields(combinator: CombinatorDeclaration): List<GeneratedField> {
        return combinator.args.map { arg ->
            generateField(arg)
        }
    }

    private fun generateField(arg: Argument): GeneratedField {
        return GeneratedField(arg.id.name, type(arg.argType.expression))
    }

    private fun type(expression: Expression): String {
        return when (expression) {
            is EExpression -> {
                val firstExpression = expression.subExpressions.firstOrNull()
                if (firstExpression != null) {
                    val result = type(firstExpression)
                    if (result == "List") {
                        return "List<${type(expression.subExpressions[1])}>"
                    }
                    return result
                }
                "Any"
            }

            is EMultiArg -> "Any"
            is ENat -> "Int"
            is EBangOperator -> "Any"
            is EPercentOperator -> "Any"
            is EPlusOperator -> "Any"
            is ETypeIdentifier -> {
                when (expression.id.name) {
                    "int" -> "Int"
                    "long" -> "Long"
                    "bytes" -> "ByteArray"
                    "vector" -> "List"
                    "Bool" -> "Boolean"
                    "int256" -> "ByteArray"
                    "#" -> "Int"
                    else -> {
                        if (expression.id.name.contains(".")) {
                            generator.rootPackage + "." + expression.id.name.split(".").dropLast(1).joinToString(".") + "." + generator.getTypeClassName(
                                expression.id.name
                            )
                        } else {
                            generator.rootPackage + "." + generator.getTypeClassName(
                                expression.id.name
                            )
                        }
                    }
                }
            }
        }
    }

}

fun findCommonPrefix(strings: List<String>): String {
    if (strings.isEmpty()) {
        return ""
    }

    // Sort the list of strings to make it easier to find the common prefix
    val sortedStrings = strings.sorted()

    // Take the first and last strings (after sorting) for comparison
    val firstString = sortedStrings.first()
    val lastString = sortedStrings.last()

    // Find the index where the common prefix ends
    val endIndex = minOf(firstString.length, lastString.length)
    var commonPrefixEndIndex = 0

    for (i in 0 until endIndex) {
        if (firstString[i] == lastString[i]) {
            commonPrefixEndIndex++
        } else {
            break
        }
    }

    // Extract the common prefix from the first string
    return firstString.substring(0, commonPrefixEndIndex)
}
